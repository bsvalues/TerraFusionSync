Replit AI Agent: TerraFusion Platform Development Context & TaskingProject: TerraFusion Platform - A modular SaaS platform for county property assessment, data synchronization, valuation, and reporting.Current State & Architecture:You are taking over development of the TerraFusion Platform. The backend is architected as two primary services:terrafusion_gateway (Flask): The public-facing API Gateway, responsible for request routing, authentication, RBAC, and proxying calls to the core backend.terrafusion_sync (FastAPI): The core backend engine. It handles data synchronization, ETL processes, and hosts the business logic for various SaaS modules implemented as "Plugins" (FastAPI routers).Primary Reference Document:Your primary source of truth for the current project structure, existing code stubs, and the development roadmap is the "TerraFusion Platform - Handoff for Replit AI Agent" document (ID: terrafusion_handoff_to_replit_ai). Please refer to it for all file paths, code snippets, and the "Next Steps for Replit AI Agent" section.Your Mission:Your mission is to incrementally build out the functionality of the TerraFusion Platform by implementing the items listed in the "Next Steps for Replit AI Agent" section of the handoff document. Focus on creating robust, well-tested, and modular components.Key Technologies to Use:Gateway (terrafusion_gateway): Python, Flask, Requests (for calling terrafusion_sync).Sync Engine & Plugins (terrafusion_sync): Python, FastAPI, SQLAlchemy (with asyncpg for asynchronous PostgreSQL operations), Pydantic.Database: PostgreSQL (for the operational OLTP database).Orchestration (Conceptual): Airflow (for DAGs), potentially Kubernetes CronJobs.Containerization: Docker (you will need to create Dockerfiles).Configuration: Environment variables (refer to .env.sample).Initial Focus & Suggested Order (from Handoff Document "Next Steps"):Please begin with the following, working through them sequentially:Implement Database Models (Handoff Next Step #1):Locate the terrafusion_sync/ directory.Create or update terrafusion_sync/core_models.py (or a similar models/ structure).Define SQLAlchemy (async) models for key entities, starting with PropertyOperational. Consider fields like property_id, county_id, address, parcel_number, legal_description, current_assessed_value, last_sale_date, last_sale_price, year_built, area_sqft, etc.Ensure these models can be used with the AsyncSession provided by terrafusion_sync/connectors/postgres.py.Self-correction/Consideration: While the handoff mentions Alembic for migrations, for initial development, you can focus on defining the models. The agent can later be tasked with setting up Alembic.Flesh out Plugin Services (Handoff Next Step #2 - focusing on Valuation plugin first):Navigate to terrafusion_sync/plugins/valuation.py.Implement the actual business logic within the run_valuation function (and any new service functions you create).This should include using the AsyncSession (dependency injected as db) to query the operational database (using the models defined in step 1). For example, fetch details for the request_data.property_id.Perform placeholder calculations for valuation. The goal is to demonstrate the data flow and plugin structure.Ensure Pydantic schemas (ValuationRequest, ValuationResponse) are used for request/response validation.Implement/Refine Authentication & RBAC in Gateway (Handoff Next Step #4 - basic login and session):Focus on terrafusion_gateway/middleware/auth.py and create terrafusion_gateway/routes/auth_routes.py.Implement a basic login route (e.g., /auth/login) that takes username/password, validates against the MOCK_USERS (from auth.py), and on success, sets user_id and permissions in the Flask session.Ensure FLASK_SECRET_KEY is used by the Flask app for secure sessions.Refine the rbac_required_actual decorator in auth.py to properly check permissions from the session.General Guidelines for Development:Modularity: Keep components focused and well-encapsulated.Clarity: Write clean, well-commented code.Testing: While full TDD might be out of scope for initial scaffolding, keep testability in mind. You will be asked to write unit and integration tests later (Handoff Next Step #8).Configuration: Use environment variables for all configurable parameters (database URLs, API keys, service URLs) as shown in .env.sample.Error Handling: Implement robust error handling and provide meaningful error responses in APIs.Logging: Use the logging module appropriately in both services for diagnostics.Idempotency (where applicable): Consider idempotency for operations that might be retried (e.g., some sync operations).Iterate: Focus on completing one sub-task from the "Next Steps" thoroughly before moving to the next. If a step is too large, break it down.Interaction Protocol:I will provide you with one primary task at a time, usually referencing a "Next Step" from the handoff document.Please confirm your understanding and ask clarifying questions before you begin coding.Provide complete, runnable code snippets for the files you modify or create.Indicate clearly which file each code block belongs to.After implementing a step, briefly summarize what you've done and any challenges encountered.Let's begin with: Implement Database Models (Handoff Next Step #1).Please define the initial SQLAlchemy models, starting with PropertyOperational, in a suitable file within terrafusion_sync/ (e.g., terrafusion_sync/core_models.py). Ensure they are compatible with an async setup.